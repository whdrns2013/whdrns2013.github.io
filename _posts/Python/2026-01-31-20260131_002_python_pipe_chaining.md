---
title: "파이프 체이닝 Pipe Chaining - 랭체인에서 파이프(`|`)로 요소들을 묶는 기법" # 제목 (필수)
excerpt: "랭체인, 에어플로에서 연산자로 요소들을 묶는 기법"  # 서브 타이틀이자 meta description (필수)
date: 2026-01-31 21:52:00 +0900      # 작성일 (필수)
lastmod: 2026-01-31 21:52:00 +0900   # 최종 수정일 (필수)
last_modified_at: 2026-01-31 21:52:00 +0900   # 최종 수정일 (필수)
categories: Python        # 다수 카테고리에 포함 가능 (필수)
tags: python 파이썬 파이프 체이닝 파이프체이닝 pipe chaining 연산자 오버로딩 operator overloading 에어플로 airflow 랭체인 langchain lcel                     # 태그 복수개 가능 (필수)
classes: wide        # wide : 넓은 레이아웃 / 빈칸 : 기본 //// wide 시에는 sticky toc 불가
toc: true        # 목차 표시 여부
toc_label:       # toc 제목
toc_sticky: true # 이동하는 목차 표시 여부 (toc:true 필요) // wide 시에는 sticky toc 불가
header: 
  image:         # 헤더 이미지 (asset내 혹은 url)
  teaser:        # 티저 이미지??
  overlay_image: /assets/images/banners/banner.gif            # 헤더 이미지 (제목과 겹치게)
  # overlay_color: '#333'            # 헤더 배경색 (제목과 겹치게) #333 : 짙은 회색 (필수)
  video:
    id:                      # 영상 ID (URL 뒷부분)
    provider:                # youtube, vimeo 등
sitemap :                    # 구글 크롤링
  changefreq : daily         # 구글 크롤링
  priority : 1.0             # 구글 크롤링
author: # 주인 외 작성자 표기 필요시
permalink: 
sidebar:
  nav: docs_llm
pinned: 
---
<!--postNo: 20260131_002-->


## 파이프 체이닝  

### Intro  

Langchain 을 공부하다가 다음과 같은 흥미로운 표현 방법을 발견했습니다.  

```python
chain = prompt | llm | parser
```

<br>

이 표현 방법은 **LCEL(LangChain Expression Language)**이라는 표현법으로, 프롬프트, LLM, 파서를 **하나의 파이프라인으로 묶어 연속된 작업**을 처리하게끔 하는 표현 방법입니다.  

이걸 보고 처음엔 "이게 도대체 무슨 문법이야.." 하다가 이와 비슷한 표현 방법을 이전에도 본 기억이 떠올랐습니다. 바로 airflow에서요.  

```python
# airflow 의 태스크 파이프라인
start > task1 > group1 > integration_task > end
start > task1 > group2 > integration_task > end
start > task1 > group3 > end
```

분명 저건 gt(greater than) 연산자인데, 어떻게 파이프라인의 전후를 묶는 역할을 하는 걸까요. 이번 포스팅에서는 그 방법을 알아보도록 하겠습니다.  

<br>

### 개념    

- LCEL에서와 같이 파이프(`|`)로 전후 작업을 묶는 것을 **파이프 체이닝(Pipe Chaining)** 이라고 지칭합니다.  
- 파이프 체이닝은 생각보다 그 역사가 깊은데, 바로 유닉스 운영체제에서 프로세스 간 통신 매커니즘인 파이프라인(`|`) 입니다.  
- 유닉스에서 파이프라인은 앞의 프로세스의 출력을 뒤 프로세스의 입력으로 주는 기능을 합니다.  

```bash
$ netstat -nltp | grep 8087

# netstat -nltp : 현재 포트 정보를 프로세스와 함께 표시 -> 출력 : 포트, 프로세스 정보
# grep 8087 : 입력에서 "8087"이 포함된 line을 찾아 출력
```

### 파이썬에서의 구현  

- 파이썬에서는 이를 **연산자 오버로딩(Operator Overloading)을 통해 구현**할 수 있습니다.  
- 쉽게 말해, 원래는 or의 뜻을 가진 연산자 `|`를 오버로딩해 역할을 바꾸는 것입니다.  
- 연산자 오버로딩에 대한 설명 : [포스팅 - [Python] 연산자 오버로딩 Operator Overloading](https://whdrns2013.github.io/python/20260131_001_python_operator_overloading/)  
- LCEL의 파이프 체이닝을 흉내내본다면 아래와 같이 표현할 수 있을 것입니다.  

```python
from abc import ABC, abstractmethod

class LCELObject(ABC):
    def __or__(self, next_object):
        return Chain(self, next_object)
    @abstractmethod
    def process(self, something):
        pass

class Chain:
    def __init__(self, first, second):
        self.first = first
        self.second = second
    def invoke(self, data):
        first_result = self.first.process(data)
        final_result = self.second.process(first_result)
        return final_result

class Prompt(LCELObject):
    def __init__(self, prompt):
        self.prompt = prompt
    def process(self, data:str):
        if data is not None:
            self.prompt = data
        return self.prompt

class LLM(LCELObject):
    def __init__(self, config):
        self.config = config
        self.name = config.get("name")
    def process(self, data):
        return self.name + f" AI 응답 : {data}에 대한 AI 응답입니다."
```

- `LCELObject` : Prompt, LLM, Parser 와 같은 LCEL 표현법의 오브젝트들  
- `Chain` : LCEL 오브젝트들의 선후관계를 묶은 체인  
- LCELObject 들은 모두 `process`라는 작업 실행 메서드를 가지고 있음  
- Chain 은 전체 파이프라인을 실행시키는 `invoke`라는 메서드를 가지고 있음  

```python
prompt = Prompt("당신은 사용자를 돕는 상담사입니다.")
llm = LLM({"name":"샘플 LLM"})

chain = prompt | llm
result = chain.invoke("안녕하세요?")
print(result)
```

- prompt와 llm 설정을 지정한 뒤 실행  

```bash
샘플 LLM AI 응답 : 안녕하세요?에 대한 AI 응답입니다.
```


## Reference  

[https://en.wikipedia.org/wiki/Pipeline_(Unix)](https://en.wikipedia.org/wiki/Pipeline_(Unix))  