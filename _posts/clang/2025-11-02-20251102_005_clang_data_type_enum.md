---
title: "[C언어] 자료형 04. 열거형 enum" # 제목 (필수)
excerpt: "" # 서브 타이틀이자 meta description (필수)
date: 2025-11-02 01:20:00 +0900      # 작성일 (필수)
lastmod: 2025-11-02 01:20:00 +0900   # 최종 수정일 (필수)
last_modified_at: 2025-11-02 01:20:00 +0900   # 최종 수정일 (필수)
categories: clang        # 다수 카테고리에 포함 가능 (필수)
tags: c clang 언어 c언어 자료형 데이터타입 datatype data type 열거형 enum enumeration                    # 태그 복수개 가능 (필수)
classes:         # wide : 넓은 레이아웃 / 빈칸 : 기본 //// wide 시에는 sticky toc 불가
toc: true        # 목차 표시 여부
toc_label:       # toc 제목
toc_sticky: true # 이동하는 목차 표시 여부 (toc:true 필요) // wide 시에는 sticky toc 불가
header: 
  image:         # 헤더 이미지 (asset내 혹은 url)
  teaser:        # 티저 이미지??
  overlay_image: /assets/images/banners/banner.gif            # 헤더 이미지 (제목과 겹치게)
  # overlay_color: '#333'            # 헤더 배경색 (제목과 겹치게) #333 : 짙은 회색 (필수)
  video:
    id:                      # 영상 ID (URL 뒷부분)
    provider:                # youtube, vimeo 등
sitemap :                    # 구글 크롤링
  changefreq : daily         # 구글 크롤링
  priority : 1.0             # 구글 크롤링
author: # 주인 외 작성자 표기 필요시
---
<!--postNo: 20251102_005-->


## 열거형  

### 정의  

- enumeration type, enum  
- 정수 상수의 집합에 이름을 부여하여, 코드를 읽기 쉽게 만들고 오류를 줄이는 데 사용하는 자료형  
- 나열된 순서대로 0부터 시작하는 정수를 뜻한다.  
- **나만의 char 자료형**으로 비유할 수 있다. char 형도 정수값마다 문자가 매칭되는 것과 같이, enum 또한 정수와 그 정수를 뜻하는 이름이 매칭된다. (비유다.)  
- 열거형 변수는 컴파일이 될 때 할당된 정수값으로 치환된다.  

### 열거형 알아보기    

#### 기본 사용법  

- `enum`이라고 표현한다.(enumeration type)  
- `enum 변수명 {값1, 값2 ..};` 와 같이 표현한다.  
- enum 의 각 이름에는 0부터 +1씩 증가되는 정수값이 할당된다.  

```c
// 사용법
enum sample {ON, OFF, RUNNING};

printf(ON);
>> 0
printf(OFF);
>> 1
printf(RUNNING);
>> 2
```

#### 특정 값 지정  

- 특정 이름에 특정 값을 지정할 수 있다.  
- 특정 이름 이후의 이름에는, 특정 값으로부터 +1씩 증가되는 정수값이 할당된다.  

```c
enum fruit {APPLE, BANANA, CHOCOLATE=10, DOTORI};

printf("%s의 값 = %d\n", "APPLE", APPLE);
>> 0
printf("%s의 값 = %d\n", "BANANA", BANANA);
>> 1
printf("%s의 값 = %d\n", "CHOCOLATE", CHOCOLATE);
>> 10
printf("%s의 값 = %d\n", "DOTORI", DOTORI);
>> 11
```

#### 할당된 정수값이 충돌하는 경우  

- 두 개 이상의 enum 변수에 동일한 정수값을 할당하는 경우, 나중에 선언된 변수만이 유지된다.  

```c
// enum에 할당된 값이 충돌되는 경우
enum ABC {A=1, B=0, C};
printf("%s의 값 = %d\n", "A", A);
>> 출력 없음
printf("%s의 값 = %d\n", "B", B);
>> B의 값 = 0
printf("%s의 값 = %d\n", "C", C);
>> C의 값 = 1
```

#### 열거형의 크기  

- 해당 열거형 그룹 변수에 할당된 정수값 중 가장 큰 정수값을 표현할 수 있는 자료형의 크기로 정해진다. (개수와는 관련 없음)  

```c
// size of
enum SMALL_ENUM {a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p};
enum BIG_ENUM {q, r, s=50000000000LL};

printf("%s의 size : %d\n", "SMALL_ENUM", sizeof(enum SMALL_ENUM));
>> SMALL_ENUM의 size : 4

printf("%s의 size : %d\n", "BIG_ENUM", sizeof(enum BIG_ENUM));
>> BIG_ENUM의 size : 8
```


### 사용하는 이유  

- 코드성으로 관리하는 데이터에 대해 쉽게 표현할 수 있다.  
- 이에 따라 코드를 읽기 쉬워지며, 코드를 잘못 작성할 확률도 줄어든다.  

```c
// 예시 : 로그레벨
enum LOG_LEVEL {
	DEBUG,        // -- 0
	INFO=10,      // -- 10
	WARNING=20,   // -- 20
	ERROR=30      // -- 30
	};

void logging_warn(int log_level_in, char* message){
	if (log_level_in >= WARNING){
	printf("[WARNING] %s", message);
	}
}

void logging_test(){
	int log_level_custom = INFO;
	logging_warn(log_level_custom, "INFO 테스트 메시지입니다.");
	log_level_custom = WARNING;
	logging_warn(log_level_custom, "WARNING 테스트 메시지입니다.");
}
```

```base
# 출력
[WARNING] WARNING 테스트 메시지입니다.
```


### 열거형 매핑테이블 만들기  

- 특정 enum에 대한 이름값이 궁금할 경우, 별도 매핑테이블을 만들어줘야 한다.  

```c
enum TAKE_OUT_YN {TAKEOUT=1, FOR_HERE=0};
const char* take_out_array[] = {
	"TAKEOUT",
	"FOR_HERE"
};

int idx = 0;
printf("%d번 인덱스의 이름값 : %s", idx, take_out_array[idx]);

>> 0번 인덱스의 이름값 : TAKEOUTA의 값 = 1
```


## Reference  

C 프로그래밍 (김형근, 곽덕훈, 정재화 공저)  
C 프로그래밍 강의 (방송통신대 - 이병래)  
