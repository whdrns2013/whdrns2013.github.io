---
title: 코딩테스트 제목 풀이 (문제출제 사이트) 언어 # 제목
excerpt: # 서브 타이틀
date: 2026-01-14 22:12:00 +0900      # 작성일
lastmod: 2026-01-14 22:12:00 +0900   # 최종 수정일 : 구글 사이트등록 관련 필요
last_modified_at: 2026-01-14 22:12:00 +0900   # 최종 수정일 (필수)
categories: coding_test         # 다수 카테고리에 포함 가능
tags: 프로그래머스 코딩테스트 파이썬                     # 태그 복수개 가능
classes:  wide       # wide : 넓은 레이아웃 / 빈칸 : 기본 //// wide 시에는 sticky toc 불가
toc: true        # 목차 표시 여부
toc_label:       # toc 제목
toc_sticky: true # 이동하는 목차 표시 여부 (toc:true 필요) // wide 시에는 sticky toc 불가
header: 
  image:         # 헤더 이미지 (asset내 혹은 url)
  teaser:        # 티저 이미지??
  overlay_image:   /assets/images/banners/banner.gif          # 헤더 이미지 (제목과 겹치게)
  overlay_color:             # 헤더 배경색 (제목과 겹치게) #333 : 짙은 회색
  video:
    id:                      # 영상 ID (URL 뒷부분)
    provider:                # youtube, vimeo 등
sitemap :                    # 구글 크롤링
  changefreq : daily         # 구글 크롤링
  priority : 1.0             # 구글 크롤링
author: # 주인 외 작성자 표기 필요시
permalink: 
sidebar:
  nav: 
pinned: 
---
<!--postNo: -->

[코딩 테스트 연습 문제](https://user-faq.grepp.co/ko/articles/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%99%B8%EB%B6%80%EC%97%90-%EA%B2%8C%EC%8B%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-3f8537c9#%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%97%B0%EC%8A%B5-%EB%AC%B8%EC%A0%9C)
코딩테스트 연습에 공개된 문제는 (주)그렙이 저작권을 가지고 있습니다.(지문 하단에 별도 저작권 표시 문제 제외)[코딩테스트 연습](https://programmers.co.kr/learn/challenges) 문제의 지문, 테스트케이스, 풀이 등과 같은 정보는 **비상업적, 비영리적 용도**로 게시할 수 있습니다.다만 문제의 지문, 풀이 등과 같은 정보를 단순히 게시하는 것을 넘어, 이를 바탕으로 문제를 풀고 채점이 가능하도록 하는 등의 방식으로 활용하는 것은 제한됩니다.
※ 2020 KAKAO BLIND RECRUITMENT, Summer/Winter Coding 등의 문제는 기업 코딩 테스트에 나온 문제이나, [코딩테스트 연습](https://programmers.co.kr/learn/challenges)에 공개된 문제이기 때문에 마찬가지로 **비상업적, 비영리적 용도**로 게시할 수 있습니다.
(2021. 01. 08 업데이트)
{: .notice--info}  

## 문제 정보  

- 프로그래머스  
- python  
- level 3  
- 점수 : 12  
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/389481)  


### 문제  

<details>
<summary> 문제 설명 펼치기/접기 </summary>
<div markdown='1'>

**봉인된 주문**

어느 날, 전설 속에 전해 내려오는 비밀 주문서가 세상에 다시 모습을 드러냈습니다. 이 주문서에는 마법 세계에서 사용되는 모든 주문이 적혀 있는데, 각 주문은 알파벳 소문자 11글자 이하로 구성되어 있습니다. 주문서에는 실제로 마법적 효과를 지니지 않는 의미 없는 주문들 즉, 알파벳 소문자 11글자 이하로 쓸 수 있는 모든 문자열이 고대의 규칙에 따라 아래와 같이 정렬되어 있습니다.

1. 글자 수가 적은 주문부터 먼저 기록된다.
2. 글자 수가 같다면, 사전 순서대로 기록된다.

예를 들어, 주문서의 시작 부분은 다음과 같이 구성됩니다.

- "a"→"b"→"c"→"d"→"e"→"f"→...→"z"
- →"aa"→"ab"→...→"az"→"ba"→...→"by"→"bz"→"ca"→...→"zz"
- →"aaa"→"aab"→...→"aaz"→"aba"→...→"azz"→"baa"→...→"zzz"
- →"aaaa"→...→"aazz"→"abaa"→...→"czzz"→"daaa"→...→"zzzz"
- →"aaaaa"→...

하지만 이 주문서에는 오래전 봉인된 저주받은 주문들이 숨겨져 있었고, 이를 악용하려는 자들을 막기 위해 마법사들이 몇몇 주문을 주문서에서 삭제했습니다. 당신은 삭제가 완료된 주문서에서 `n`번째 주문을 찾아내야 합니다.

예를 들어, 주문서에서 "d", "e", "bb", "aa", "ae" 5개의 주문을 지웠을 때, 주문서에서 30번째 주문을 찾으려고 합니다.

- 1~3번째 주문은 "a", "b", "c" 입니다.
- "d"와 "e"는 삭제됐으므로 4~24번째 주문은 "f" ~ "z"입니다.
- "aa"는 삭제됐으므로 25~27번째 주문은 "ab", "ac", "ad"입니다.
- "ae"는 삭제됐으므로 28~30번째 주문은 "af", "ag", "ah"입니다.

따라서 30번째 주문은 "ah"가 됩니다. 삭제된 주문 중 “bb”와 같이 `n`번째 주문보다 뒤에 위치해 있어서 `n`번째 주문을 찾는 데 영향을 주지 않는 주문도 존재할 수 있습니다.

정수 `n`과 삭제된 주문들을 담은 1차원 문자열 배열 `bans`가 매개변수로 주어질 때, 삭제가 완료된 주문서의 `n`번째 주문을 return 하도록 solution 함수를 완성해 주세요.

---

### 제한사항

- 1 ≤ `n` ≤ 10
    
    15
    
- 1 ≤ `bans`의 길이 ≤ 300,000
    - `bans`의 원소는 알파벳 소문자로만 이루어진 길이가 1 이상 11 이하인 문자열입니다.
    - `bans`의 원소는 중복되지 않습니다.

---

### 입출력 예

| n | bans | result |
| --- | --- | --- |
| 30 | ["d", "e", "bb", "aa", "ae"] | "ah" |
| 7388 | ["gqk", "kdn", "jxj", "jxi", "fug", "jxg", "ewq", "len", "bhc"] | "jxk" |

---

### 테스트 케이스 구성 안내

아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.

| 그룹 | 총점 | 추가 제한 사항 |
| --- | --- | --- |
| #1 | 15% | `n` ≤ 1,000, `bans`의 길이 ≤ 100 |
| #2 | 15% | `n` ≤ 1,000,000 |
| #3 | 70% | 추가 제한 사항 없음 |

---

### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

주어진 주문을 지운 후 주문서의 7,388 번째 주문은 "jxk"입니다.

따라서 "jxk"를 return 합니다.

</div>
</details>

## 풀이  

### 풀이 코드  

```python
def num_to_spell(n): # 숫자를 문자열(주문)로 변환
    spell = ""
    while n > 0:
        n = n-1
        remainder = n % 26
        spell += chr(97 + remainder)
        n = n // 26
    return spell[::-1]

def spell_to_num(spell:str): # 문자열(주문)을 숫자로 변환
    result = 0
    for i, char in enumerate(spell[::-1]):
        result += (ord(char) - 97 + 1)*(26**i)
    return result

def solution(n, bans):
    # 제외할 주문을 숫자료 변환하고 정렬
    bans = [spell_to_num(ban) for ban in bans]
    bans.sort()
    # 제외할 숫자 개수 탐색 (upper)
    prev = 0
    cur_n = n
    while prev != cur_n: # 제외할 개수는 동적으로 움직여야 하므로
        prev = cur_n
        left, right = 0, len(bans)
        while left < right: # 이진탐색
            mid = (left + right) // 2
            if bans[mid] <= cur_n:
                left = mid + 1
            else:
                right = mid
        cur_n = n + left
    n = cur_n
    answer = num_to_spell(n)
    return answer
```

### 풀이 방식  

이번 문제풀이에는 총 세가지 포인트가 있다.  

#### n번째 주문을 찾는 방법  

- 알파벳을 26진수라고 여기고, n/26 을 반복하여 구성 알파벳을 찾는다.    
- 알파벳 소문자 a 의 ASCII 는 97이므로 n=20 일 경우 결과 주문은 chr(97 + 20%26 - 1) = 't'  

```python
def num_to_spell(n): # 숫자를 문자열(주문)로 변환
    spell = ""
    while n > 0:
        n = n-1
        remainder = n % 26
        spell += chr(97 + remainder)
        n = n // 26
    return spell[::-1]
```

#### 주문을 숫자로 변환하는 방법  

- 이 문제는 여러모로 주문을 숫자로 변환하면 빠른 연산이 가능하다.  
- 위에서 본 "n번째 주문을 찾는 방법"과 같은 결로 수행한다.  

```python
def spell_to_num(spell:str): # 문자열(주문)을 숫자로 변환
    result = 0
    for i, char in enumerate(spell[::-1]):
        result += (ord(char) - 97 + 1)*(26**i)
    return result
```

#### 제거된 주문을 제외하는 방법  

- 우선 빠른 주문(a, b...)부터 제거되어야 하므로, 제거될 주문을 정렬해야 한다  
- 제거된 주문은, 그 뒤의 주문들의 제거 여부에도 영향을 미친다. 따라서 동적으로 주문을 제거해야 한다. (아래 예시)  
- 시간복잡도를 낮추기 위해 이진탐색을 적용했다.  




## 리뷰  

