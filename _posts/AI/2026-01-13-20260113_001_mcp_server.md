---
title: "[MCP] MCP 서버의 개념과 Tool, Resource, Prompt" # 제목 (필수)
excerpt: "LLM에게 세상을 알려주는 MCP 서버에 대해 알아보자" # 서브 타이틀이자 meta description (필수)
date: 2026-01-13 00:17:00 +0900      # 작성일 (필수)
lastmod: 2026-01-13 00:17:00 +0900   # 최종 수정일 (필수)
last_modified_at: 2026-01-13 00:17:00 +0900   # 최종 수정일 (필수)
categories: AI         # 다수 카테고리에 포함 가능 (필수)
tags: MCP 서버 server 구축 개념 tool resource prompt user interface 도구 리소스 프롬프트 tools resources prompts                     # 태그 복수개 가능 (필수)
classes: wide        # wide : 넓은 레이아웃 / 빈칸 : 기본 //// wide 시에는 sticky toc 불가
toc: true        # 목차 표시 여부
toc_label:       # toc 제목
toc_sticky: true # 이동하는 목차 표시 여부 (toc:true 필요) // wide 시에는 sticky toc 불가
header: 
  image:         # 헤더 이미지 (asset내 혹은 url)
  teaser:        # 티저 이미지??
  overlay_image: /assets/images/banners/banner.gif            # 헤더 이미지 (제목과 겹치게)
  # overlay_color: '#333'            # 헤더 배경색 (제목과 겹치게) #333 : 짙은 회색 (필수)
  video:
    id:                      # 영상 ID (URL 뒷부분)
    provider:                # youtube, vimeo 등
sitemap :                    # 구글 크롤링
  changefreq : daily         # 구글 크롤링
  priority : 1.0             # 구글 크롤링
author: # 주인 외 작성자 표기 필요시
permalink: 
sidebar:
  nav: docs_llm
pinned: 
---
<!--postNo: 20260113_001-->

## MCP 서버의 개념 - Tool, Resource, Prompt

### 공식 정의

> “A program that provides context to MCP clients”  
> MCP Client에 Context를 제공하는 프로그램  

> programs that expose specific capabilities to AI applications through standardized protocol interfaces.  
> AI 애플리케이션이 특정 기능이나 데이터에 접근할 수 있도록 표준화된 프로토콜 인터페이스를 통해 기능을 제공하는 프로그램  

### 개념

MCP 체계에서 가장 중요한 것은 **표준화**라고 생각합니다. 중구난방으로 개발될 수 있는 Tool들에 대해 표준을 마련함으로써 상호 간의 호환성과 확장성도 높아지고, 결과적으로 생산성 또한 높아지기 때문입니다.  

그리고 그 다음으로 중요한 게 무엇이냐고 묻는다면, 저는 **MCP 서버**라고 답할 것 같습니다.   

공식 문서에서는 MCP 서버를 “MCP Client 에 Context를 제공하는 프로그램” 이자, “데이터(Resource)나 실행 가능한 Tool(도구)을 노출(expose)하는 역할”을 수행한다고 정의하고 있습니다. MCP의 목적이 **LLM에게 외부의 정보, 즉 Context 를 제공하고 외부 세계와 상호작용하기 위함**이라는 점을 고려하면, 이 목적을 가능케 하는 것은 **모두 MCP 서버를 통해 제공되기 때문**입니다.  


### 종류

- MCP 서버는 Tool, Resource, Prompt 세 가지로 분류됩니다.

| 종류 | 설명 | 예시 | 핸들링 주체 |
| --- | --- | --- | --- |
| `Tools`<br>도구 | - LLM이 능동적으로 호출할 수 있는 기능<br>- 파일을 수정하거나, 외부 API를 호출하거나, 데이터베이스 쓰기 등<br>- “능동적”이라는 점에서 Resource와 차이가 있다. | 항공편 검색<br>메시지 보내기<br>캘린더 일정 생성 | 모델 |
| `Resources`<br>자원 | - 데이터 “읽기 전용” 접근을 제공하는 수동 데이터 소스<br>- 파일 읽기, 데이터베이스 조회, 문서 검색 등<br>- “읽기 전용”, “수동적”이라는 점이 Tools 와 차이가 있다. | 문서 검색<br>일정 조회 | AI 애플리케이션 |
| `Pormpts`<br>프롬프트 | - 미리 만들어진 지침 템플릿<br>- 모델이 특정 도구나 리소스를 사용하도록 지시한다. | 휴가 계획 세우기<br>회의 요약하기<br>이메일 초안 작성 | 사용자 |

## 1. Tools

### 개념

- MCP 환경에서 **AI 모델이 능동적으로 호출할 수 있는 함수(기능)**  
- 외부 **API 호출, 파일 수정, 데이터베이스 쓰기 등** 시스템에서 동작을 일으키는 기능  
- Resources 가 “읽기 전용”이라면,  Tools는 시스템에 변화를 주거나 외부와 상호작용하는 “행동”을 담당  

### 역할

- AI 모델의 손과 발, 즉 실행 능력
- AI 모델이 단순한 텍스트 응답을 넘어 외부 시스템과 상호작용할 수 있도록 함

### 특징

- 제어 주체 : 모델 주도적 실행  
    - 사용자가 직접 도구를 실행하는 게 아니라, **AI 모델이 대화 맥락을 파악해 언제 어떤 도구를 사용할지 결정**  
- 명확한 규격  
    - JSON Schema를 사용해 입력값과 출력값을 명확히 정의함  
- 안전 장치  
    - Tool은 시스템과 데이터에 변화를 줄 수 있으므로 안전장치가 필요함  
    - 필요시 작업 실행 전에 사용자의 동의를 요구할 수 있음  

### Tool의 표준 동작 목록 Protocol Operations

| Method | Purpose | Returns |
| --- | --- | --- |
| `tools/list`  | 사용 가능한 Tool 을 탐색한다. | Tool들의 정의 및 스키마를 담은 배열 |
| `tools/call`  | 특정(지정) Tool 을 실행시킨다. | Tool 실행 결과 |

### 예시 : 여행 예약

#### 항공편 검색 Tool  

- Tool 템플릿 예시

```json
{
	name: "searchFlights",
	description: "이용 가능한 항공편 검색",
	inputSchema: {
		type: "object",
		properties: {
			origin: {type:"string", description:"출발 도시"},
			destination: {type:"string", description:"도착 도시"},
			date: {type:"string", format:"date", description: "여행 일수"}
		},
		required: ["origin", "destination", "date"]
	}
}
```

- 사용

```python
searchFlights(origin: "NYC", destination: "Barcelona", date: "2024-06-15")
```

#### 캘린더에 일정 추가  

```python
createCalendarEvent(title: "Barcelona Trip", startDate: "2024-06-15", endDate: "2024-06-22")
```

#### 이메일 알림

```python
sendEmail(to: "team@work.com", subject: "Out of Office", body: "...")
```

### 사용자와의 상호작용 설계 원칙 (User Interface Model)

- Tool은 AI 모델이 주도적으로 사용할 수도 있지만, **최종 결정과 감시는 항상 인간(사용자)의 통제하**에 있어야 합니다.
- 즉, 신뢰와 안전을 위해 MCP Tools 서버를 설계할 때 아래와 같은 인간의 **개입 장치**를 두는 것이 권장됩니다.

| 개입 장치 | 설명 |
| --- | --- |
| UI 내 도구 표시<br>Displaying available Tool | UI 상에 사용가능한 Tool 목록을 표시하여, 특정 대화나 상황에서 어떤 Tool을 사용할 수 있을지 사용자가 직접 설정할 수 있도록 한다. |
| 실행 승인 대화상자<br>Dialog for Tool Exec | AI가 도구를 실행하기 직전에 승인 다이얼로그를 띄워 사용자에게 확인을 요구한다. |
| 권한 설정<br>Permission Settings | 비교적 안전한 작업에 대해서는 사전 승인(permission) 설정을 통해 자동 실행을 허용한다. |
| 활동 로그<br>Activity Log | AI가 실행한 모든 Tool과 그 결과를 확인할 수 있는 활동 로그를 제공한다. |

## 2. 리소스 (Resources)

### 개념

- AI가 필요로 할 수 있는 **정보들을 가져갈 수 있게 노출시켜놓는 데이터 제공자**
- 파일, API, 데이터베이스 등 AI 가 Context를 이해하는 데 필요한 데이터를 노출시킨다.

### 역할

- 컨텍스트 제공 : LLM의 질문 이해와 답변의 품질을 높일 수 있는 배경 지식(Context)를 제공한다.
- 외부 데이터 연결 : LLM이 사전에 학습하지 않은 실시간 데이터나 학습되지 않은 정보들을 모델이 참조할 수 있게 제공한다.
- 정보의 구조화 : 방대한 데이터를 무작위로 전달하는 게 아니라, URI 체계를 통해 필요한 정보만 전달할 수 있게 한다.

### 특징

- **읽기 전용** : Tool과 달리 데이터를 변경하거나 외부 시스템에 영향을 주지 않음
- 제어 주체 - **애플리케이션 중심** : 어떤 리소스를 제공할지, 어떻게 구조화할지는 애플리케이션과 사용자 레벨에서 결정됨

> Tools와의 차이
> - Tools: 모델 중심 - 모델이 호출 판단을 주도할 수 있으나, 실행 권한은 애플리케이션이 통제
> - Resources: 애플리케이션 중심 - 노출 범위와 구조 자체가 애플리케이션에 의해 사전에 정의됨

### 리소스의 두 가지 탐색 패턴(종류)

| 패턴 | 설명 | 예시 |
| --- | --- | --- |
| 직접 리소스<br>Direct Resource | 별도의 조회 조건 없이 항상 동일한 데이터를 반환하는 고정된 리소스 | calendar://events/2024<br>→ 2024년의 캘린더 반환 |
| 리소스 템플릿<br>Resource Template | 파라미터에 따라 내용이 바뀌는 동적 리소스 | travel://activities/{city}/{category}<br>→ 도시, 분야 파라미터에 따라 다른 응답 |

### Resource 의 표준 동작 목록 Protocol Operations

| Method | Purpose | Returns |
| --- | --- | --- |
| `resources/list` | 사용 가능한 직접 리소스 목록 | 리소스 설명을 담은 배열 |
| `resources/templates/list` | 리소스 템플릿 검색 | 리소스 템플릿 정의를 담은 배열 |
| `resources/read` | 리소스 내용 및 메타데이터 가져오기 | 요청한 리소스 내용과 그에 대한 메타데이터 |
| `resources/subscribe`  | 리소스 변경 사항 모니터링 | 리소스를 구독하고, 리소스에 변경사항이 확인됐을 때  알림을 받음 |

### 예시

#### 리소스 템플릿 예시  

- 날씨 데이터 : 원하는 도시와 날짜 조합에 대한 일기 예보 정보를 제공

```json
// 정의
{
  "uriTemplate": "weather://forecast/{city}/{date}",
  "name": "weather-forecast",
  "title": "일기 예보",
  "description": "도시와 날짜를 기준으로 일기 예보를 조회",
  "mimeType": "application/json"
}
```

```bash
# 사용
weather://forecast/barcelona/2026-01-18
```

- 항공편 : 원하는 두 공항 간의 항공편 정보를 제공

```json
// 정의
{
  "uriTemplate": "travel://flights/{origin}/{destination}",
  "name": "flight-search",
  "title": "항공편 검색",
  "description": "두 도시 간의 이용 가능한 항공편 검색",
  "mimeType": "application/json"
}
```

```bash
# 사용
travel://flights/NYC/BCN
```

#### 매개변수 자동 완성 Parameter Completion  

- 파라미터를 입력해야하는 동적 리소스에 대해서 자동 완성 기능을 제공할 수도 있습니다.
- 예) 일기예보 리소스의 `{city}` 에 **Par** 라는 값을 입력할 경우, **Paris** 또는 **Park City** 등, 의도에 맞는 유효값을 제공
- 즉, 정확한 값의 형식을 몰라도 유효한 파라미터를 보낼 수 있도록 돕는 것입니다.

### 사용자와의 상호작용 설계 원칙 (User Interface Model)

- Resource는 애플리케이션 주도로 관리됩니다.
- 따라서 리소스를 어떻게 탐색(검색)하고, 선택하며, 컨텍스트로 포함할지를 **애플리케이션이 자유롭게 설계할 수 있어야** 합니다.
- 따라서 사용자와의 다양하고 **유연한 상호작용 방식**(검색이나 필터링, 자동 추천, 일괄 선택 등)을 허용하는 것이 바람직합니다.

| 인터페이스 패턴 예시 | 의미 |
| --- | --- |
| Tree / List View | 사용자에게 익숙한 “폴더 구조”처럼 트리 또는 리스트 뷰 |
| Search / Filter | 특정 리소스를 빠르게 찾기 위한 검색 및 필터 인터페이스 |
| Automatic Inclusion / Smart Suggestion | 휴리스틱 또는 AI 선택에 기반한 자동 컨텍스트 제안 |
| Manual / Bulk Selection | 단일 또는 다중 리소스를 직접, 일괄로 선택하는 인터페이스 |

## 3. 프롬프트 Prompt

### 개념

- 프롬프트는 여러 상황에서 반복해 사용할 수 있는 **“구조화된 프롬프트 템플릿”**을 의미합니다.
- 프롬프트는 사용자가 명시적으로 선택해 실행하는 방식으로 동작합니다.
- MCP 서버 개발자는 프롬프트를 통해 아래와 같은 목적을 달성할 수 있습니다.

#### 1) 매개변수화된 프롬프트 템플릿 제공    

- 입력값(파라미터)만 바꿔가며 재사용해 쓸 수 있는 형태의 프롬프트 템플릿 제공  
- (파라미터가 없는 프롬프트도 존재할 수 있음. 파라미터는 옵셔널)  

#### 2) 해당 MCP 서버를 효과적으로 사용하는 방법 제공  

- 프롬프트 자체를 통해 이를 자연스럽게 안내할 수 있음  

> 매개변수화된 프롬프트 템플릿  
> 단순히 프롬프트 텍스트만 있는 게 아니라, 어떤 입력이 필요한지 정의되어 있어, 사용자가 값을 채워 넣으면 완성되는 구조  
> 즉, **“미리 양식이 만들어져 있는 빈칸 채우기식 주문서”**  

### 작동 방식

- 자동으로 실행되지 않으며, 사용자 주도로 **사용자가 명시적으로 호출**해 실행합니다. (사용자 제어 방식)
- 프롬프트는 현재 상황(Context)를 어느 정도 인지할 수 있어, 필요시 **이미 사용 중인 Resource나 Tool을 참고**할 수 있습니다.
- 프롬프트는 입력받은 파라미터(e.g. 목적지, 예산 등)과 Resource나 Tool 을 참고해 일관된 **워크플로우를 만들 수** 있습니다.
- 또한 프롬프트는 입력해야 할 파라미터를 안내하고, 사용자가 선택 가능한 값을 제안하거나 예시를 들어 올바르게 사용할 수 있게 도와줍니다.

### 역할

- 재사용 가능한 워크플로우 : “휴가 계획 짜기”, “회의 요약하기”와 같이 복잡한 작업을 재사용 가능한 구조화된 템플릿으로 제공
- MCP 서버 활용 가이드 : 해당 MCP 서버를 어떻게 사용해야 효과적일지 개발자가 모범 사례 제공 가능
- 리소스 및 툴과의 연결 : “이 리소스를 읽고, 이 툴을 사용해라”와 같은 복합적인 지시를 하나의 프롬프트 안에 담을 수 있음

### 특징

- 제어 주체 - 사용자 중심 제어 : Tool 처럼 AI가 알아서 실행하는 자동 트리거가 아니라, **사용자가 직접 명시적으로 호출**
- **파라미터 지원** : 예를 들어 “여행 계획” 프롬프트라면 목적지나 기간 등의 파라미터를 입력받아 유연하게 대응할 수 있음
- 상태 비저장성 : 서버는 템플릿만을 제공할 뿐, 실제 대화 맥락을 완성하고 실행하는 것은 클라이언트(앱)의 몫

### Prompt 의 표준 동작 목록 Protocol Operation

| Method | Purpose | Returns |
| --- | --- | --- |
| `prompts/list`  | 사용 가능한 프롬프트 목록을 확인한다. | 사용 가능한 프롬프트에 대한 설명을 담은 배열 |
| `prompts/get`  | 프롬프트 세부 정보를 검색한다. | 인수를 포함한 전체 프롬프트의 세부 정보(정의) |

### 예시

#### 휴가 계획하기 프롬프트 정의  

```json
{
  "name": "plan-vacation",
  "title": "Plan a vacation",
  "description": "Guide through vacation planning process",
  "arguments": [
    { "name": "destination", "type": "string", "required": true },
    { "name": "duration", "type": "number", "description": "days" },
    { "name": "budget", "type": "number", "required": false },
    { "name": "interests", "type": "array", "items": { "type": "string" } }
  ]
}
```

구조화되지 않은 자연어 입력 대신, 프롬프트 시스템은 다음과 같은 기능을 제공합니다.

1. “휴가 계획하기” 템플릿 선택
2. 구조화된 입력: 바르셀로나, 7일, 3000달러, [“해변”, “건축”, “음식”]
3. 템플릿 기반의 일관된 워크플로 실행

### 사용자와의 상호작용 설계 원칙 (User Interface Model)

#### 일반적인 원칙  

프롬프트는 사용자가 직접 명시적으로 호출해 사용됩니다. 때문에 프로토콜을 구성할 때에는, **애플리케이션에 가장 자연스럽게 어울리는 방식으로 프롬프트 UI가 설계될 수 있게**끔 충분한 자유도를 보장해주어야 합니다. 이 때 고려할 수 있는 주요 원칙은 아래와 같습니다.  

- 사용 가능한 프롬프트를 쉽게 찾을 수 있어야 한다.
- 각 프롬프트의 기능에 대한 명확한 설명이 있어야 한다.
- 유효성 검사를 포함한 자연어 인수 입력이 가능해야 한다.
- 프롬프트의 기본 템플릿을 명확하게 표시해야 한다.

#### 일반적인 프롬프트 UI 패턴  

| 패턴 | 설명 |
| --- | --- |
| **슬래시 명령어** | 슬래시 명령어(`/`) 를 입력하면, 사용 가능한 프롬프트가 표시된다. |
| **Command 팔레트** | `Ctrl + K` 나 `F1` 을 눌렀을 때 나오는 통합 검색창과 같은 검색 가능한 커맨드 팔레트를 제공 |
| **전용 UI 버튼** | 자주 쓰는 프롬프트(e.g. 코드 리뷰, 회의 요약)를 버튼으로 만들어둬 검색할 필요 없이 프롬프트를 사용할 수 있도록 한다. |
| **컨텍스트 메뉴** | 현재 상황이나 특정 대상에 맞는 프롬프트를 제안하는 컨텍스트 메뉴<br>(e.g. 로그파일 우클릭 → 로그 분석하기 프롬프트 제안) |

## 4. MCP 서버들 결합하기

MCP의 진정한 강점은 여러 서버가 하나의 통합된 인터페이스를 통해 함께 동작할 때 드러납니다. 각 서버가 가진 전문적인 기능을 결합함으로써, 단일 서버로는 어려운 복합적인 작업을 효율적으로 수행할 수 있습니다.

### 예시 : 여러 서버를 활용한 여행 계획

개인화된 AI 여행 플래너 애플리케이션을 예로 들어보겠습니다.

이 애플리케이션은 다음과 같은 세 개의 서버와 연결되어 있습니다.

- 여행 서버 : 항공편, 호텔 및 여행 일정 관리
- 기상 서버 : 기후 데이터 및 일기 예보 제공
- 캘린더, 이메일 서버 : 일정 및 커뮤니케이션 관리

### 전체 흐름

#### 1. 사용자가 프롬프트를 호출하고 파라미터를 입력한다.  

```json
{
  "prompt": "plan-vacation",
  "arguments": {
    "destination": "Barcelona",
    "departure_date": "2024-06-15",
    "return_date": "2024-06-22",
    "budget": 3000,
    "travelers": 2
  }
}
```

#### 2. 사용자가 포함할 리소스를 선택한다.  

- **`calendar://my-calendar/June-2024`**(캘린더 서버에서 가져옴)
- **`travel://preferences/europe`**(Travel Server에서 가져옴)
- **`travel://past-trips/Spain-2023`**(Travel Server에서 가져옴)

#### 3. 모델이 Tool을 활용해 요청을 처리

AI는 먼저 선택된 모든 리소스를 읽어 **컨텍스트를 수집**합니다.

- 캘린더에서 여행 가능한 날짜 확인
- 여행 선호도에서 선호 항공사 및 숙소 유형 파악
- 과거 여행 기록에서 이전에 만족했던 장소 확인

이 컨텍스트를 바탕으로, AI는 다음과 같은 Tool을 순차적으로 실행합니다.

- `searchFlights()` : 뉴욕(NYC) → 바르셀로나 항공편 검색
- `checkWeather()` : 여행 기간의 날씨 예보 조회

#### 4. 사용자의 승인과 함께 후속 작업 수행  

수집된 정보를 기반으로, AI는 예약 및 후속 작업을 진행하며 필요한 경우 사용자에게 승인을 요청합니다.  

- `bookHotel()` : 예산 범위 내 숙소 검색
- `createCalendarEvent()` : 여행 일정을 캘린더에 추가
- `sendEmail()` : 여행 세부 정보가 담긴 확인 이메일 발송

#### 결과  

- 결과적으로 사용자는 여러 MCP 서버를 통해 자신의 일정에 맞춰 바르셀로나 여행을 검색하고 예약할 수 있었습니다.  
- "휴가 계획하기" 프롬프트는 서로 다른 서버에 흩어져 있는 Resource(달력 사용 가능 여부 및 여행 이력)와 Tool(항공편 검색, 호텔 예약, 캘린더 업데이트)을 유기적으로 결합해 컨텍스트 파악부터 실제 예약 실행까지 한 번에 처리하도록 했습니다.  
- 이를 통해 과거에는 몇 시간이 걸렸을 작업이, MCP를 활용해 몇 분 만에 완료됐습니다.  

## Reference

[Understanding MCP servers - Model Context Protocol](https://modelcontextprotocol.io/docs/learn/server-concepts)

[Architecture overview - Model Context Protocol](https://modelcontextprotocol.io/docs/learn/architecture)